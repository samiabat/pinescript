//@version=5
indicator("ICT Trading Strategy - FVG + Liquidity Sweep + MSS", overlay=true, max_labels_count=500, max_boxes_count=500, max_lines_count=500)

// ============================================================================
// INPUTS
// ============================================================================

// Risk Management
risk_percent = input.float(1.5, "Risk per Trade (%)", minval=0.1, maxval=10.0, step=0.1, group="Risk Management")
max_trades_per_day = input.int(40, "Max Trades per Day", minval=1, maxval=100, group="Risk Management")
min_balance = input.float(100.0, "Min Balance Threshold (display)", minval=0, group="Risk Management")
max_daily_loss_percent = input.float(5.0, "Max Daily Loss % (display)", minval=0, maxval=50, step=0.5, group="Risk Management")

// ICT Parameters
min_FVG_pips = input.float(2.0, "Minimum FVG Size (pips)", minval=0.5, maxval=50.0, step=0.1, group="ICT Parameters")
rejection_pips = input.float(0.5, "Sweep Rejection (pips)", minval=0.1, maxval=10.0, step=0.1, group="ICT Parameters")
buffer_pips = input.float(2.0, "Stop Loss Buffer (pips)", minval=0.1, maxval=20.0, step=0.1, group="ICT Parameters")
DISPLACEMENT_CANDLE_MIN_SIZE_RATIO = input.float(0.5, "Displacement Candle Min Size Ratio", minval=0.1, maxval=2.0, step=0.1, group="ICT Parameters")

// Risk-Reward Settings
min_RR = input.float(3.0, "Minimum R:R", minval=1.0, maxval=10.0, step=0.1, group="Risk-Reward")
max_RR = input.float(5.0, "Maximum R:R", minval=1.0, maxval=10.0, step=0.1, group="Risk-Reward")
use_random_RR = input.bool(true, "Use Random R:R (between min/max)", group="Risk-Reward")
fixed_RR = input.float(3.0, "Fixed R:R (if random disabled)", minval=1.0, maxval=10.0, step=0.1, group="Risk-Reward")

// Trading Sessions (New York Time - adjusted from UTC)
london_open_hour = input.int(3, "London Open Hour (NY Time)", minval=0, maxval=23, group="Sessions")
london_close_hour = input.int(12, "London Close Hour (NY Time)", minval=0, maxval=23, group="Sessions")
ny_open_hour = input.int(8, "NY Open Hour (NY Time)", minval=0, maxval=23, group="Sessions")
ny_close_hour = input.int(17, "NY Close Hour (NY Time)", minval=0, maxval=23, group="Sessions")

// Trend Alignment
enable_trend_filter = input.bool(false, "Enable Trend Alignment", group="Trend Filter")
trend_lookback = input.int(32, "Trend Lookback Bars", minval=10, maxval=200, group="Trend Filter")

// MSS Settings
mss_lookforward_bars = input.int(30, "MSS Look-forward Bars", minval=5, maxval=100, group="MSS Detection")

// Display & Debug
spread_pips = input.float(0.6, "Spread (pips)", minval=0, maxval=10.0, step=0.1, group="Display")
show_fvg_boxes = input.bool(true, "Show FVG Boxes", group="Display")
show_sweep_markers = input.bool(true, "Show Sweep Markers", group="Display")
show_mss_markers = input.bool(true, "Show MSS Markers", group="Display")
debug_logging = input.bool(false, "Enable Debug Logging", group="Display")

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

// Convert pips to price
pips_to_price(pips) => pips * 0.0001

// Convert price to pips
price_to_pips(price_diff) => price_diff / 0.0001

// Check if current time is in trading session
is_trading_session() =>
    current_hour = hour(time)
    in_london = current_hour >= london_open_hour and current_hour <= london_close_hour
    in_ny = current_hour >= ny_open_hour and current_hour <= ny_close_hour
    in_london or in_ny

// Generate RR ratio (deterministic using bar_index for seed)
get_RR_ratio() =>
    if use_random_RR
        // Use bar_index as seed for deterministic randomness
        seed = bar_index % 1000
        min_RR + (seed / 1000.0) * (max_RR - min_RR)
    else
        fixed_RR

// ============================================================================
// TREND DETECTION
// ============================================================================

detect_trend() =>
    recent_bars = 8
    older_bars = 8
    
    // Recent highs/lows (called unconditionally for Pine Script consistency)
    recent_high = ta.highest(high, recent_bars)
    recent_low = ta.lowest(low, recent_bars)
    
    // Older highs/lows (offset by recent_bars)
    older_high = ta.highest(high[recent_bars], older_bars)
    older_low = ta.lowest(low[recent_bars], older_bars)
    
    trend = "neutral"
    if bar_index >= trend_lookback
        if recent_high > older_high and recent_low > older_low
            trend := "bullish"
        else if recent_high < older_high and recent_low < older_low
            trend := "bearish"
    trend

// ============================================================================
// LIQUIDITY SWEEP DETECTION
// ============================================================================

detect_liquidity_sweep() =>
    sweep_type = ""
    sweep_price = 0.0
    sweep_valid = false
    
    // Get 20-bar lookback range (called unconditionally for Pine Script consistency)
    prev_high = ta.highest(high[1], 20)
    prev_low = ta.lowest(low[1], 20)
    
    if bar_index >= 20
        // Bearish sweep: high breaks previous high + rejection
        wick_high = high - close
        if high > prev_high and close < high - pips_to_price(rejection_pips) and wick_high >= pips_to_price(rejection_pips)
            sweep_type := "bear_sweep"
            sweep_price := high
            sweep_valid := true
        
        // Bullish sweep: low breaks previous low + rejection
        wick_low = close - low
        if low < prev_low and close > low + pips_to_price(rejection_pips) and wick_low >= pips_to_price(rejection_pips)
            sweep_type := "bull_sweep"
            sweep_price := low
            sweep_valid := true
    
    [sweep_valid, sweep_type, sweep_price]

// ============================================================================
// FAIR VALUE GAP (FVG) DETECTION
// ============================================================================

detect_fvg() =>
    fvg_valid = false
    fvg_type = ""
    fvg_bottom = 0.0
    fvg_top = 0.0
    
    if bar_index >= 2
        // 3-bar pattern: c1 (old), c2 (displacement), c3 (current/new)
        c1_high = high[2]
        c1_low = low[2]
        c2_high = high[1]
        c2_low = low[1]
        c2_close = close[1]
        c2_open = open[1]
        c3_high = high
        c3_low = low
        
        // Bullish FVG: c3.low > c1.high
        if c3_low > c1_high
            gap_size = c3_low - c1_high
            gap_pips = price_to_pips(gap_size)
            
            if gap_pips >= min_FVG_pips
                // Validate displacement candle (c2) - bullish direction and size
                c2_body = math.abs(c2_close - c2_open)
                c2_is_bullish = c2_close > c2_open
                min_gap_price = pips_to_price(min_FVG_pips)
                required_c2_size = DISPLACEMENT_CANDLE_MIN_SIZE_RATIO * min_gap_price
                
                if c2_is_bullish and c2_body >= required_c2_size
                    fvg_valid := true
                    fvg_type := "bullish"
                    fvg_bottom := c1_high
                    fvg_top := c3_low
        
        // Bearish FVG: c3.high < c1.low
        if c3_high < c1_low
            gap_size = c1_low - c3_high
            gap_pips = price_to_pips(gap_size)
            
            if gap_pips >= min_FVG_pips
                // Validate displacement candle (c2) - bearish direction and size
                c2_body = math.abs(c2_close - c2_open)
                c2_is_bearish = c2_close < c2_open
                min_gap_price = pips_to_price(min_FVG_pips)
                required_c2_size = DISPLACEMENT_CANDLE_MIN_SIZE_RATIO * min_gap_price
                
                if c2_is_bearish and c2_body >= required_c2_size
                    fvg_valid := true
                    fvg_type := "bearish"
                    fvg_bottom := c3_high
                    fvg_top := c1_low
    
    [fvg_valid, fvg_type, fvg_bottom, fvg_top]

// ============================================================================
// MARKET STRUCTURE SHIFT (MSS) DETECTION
// ============================================================================

// Check if MSS occurred after sweep (using array-based approach for historical data)
check_mss_after_sweep(sweep_bar_index, current_bar_index, sweep_type, sweep_low, sweep_high) =>
    mss_confirmed = false
    
    if current_bar_index > sweep_bar_index
        bars_since_sweep = current_bar_index - sweep_bar_index
        
        if bars_since_sweep > 0 and bars_since_sweep <= mss_lookforward_bars
            // For bear_sweep: need lower low after sweep
            if sweep_type == "bear_sweep"
                // Check if any bar between sweep and current made lower low
                for i = 1 to bars_since_sweep
                    if low[bars_since_sweep - i] < sweep_low
                        mss_confirmed := true
                        break
            
            // For bull_sweep: need higher high after sweep
            if sweep_type == "bull_sweep"
                // Check if any bar between sweep and current made higher high
                for i = 1 to bars_since_sweep
                    if high[bars_since_sweep - i] > sweep_high
                        mss_confirmed := true
                        break
    
    mss_confirmed

// ============================================================================
// STATE VARIABLES (using var for persistence)
// ============================================================================

var int trades_today = 0
var float daily_pnl = 0.0
var int current_day = 0
var array<int> sweep_bar_indices = array.new<int>()
var array<string> sweep_types = array.new<string>()
var array<float> sweep_prices = array.new<float>()
var array<string> sweep_trends = array.new<string>()
var array<bool> sweep_used = array.new<bool>()

// Arrays to track active trades for outcome visualization
var array<int> trade_entry_bars = array.new<int>()
var array<float> trade_entry_prices = array.new<float>()
var array<float> trade_sl_prices = array.new<float>()
var array<float> trade_tp_prices = array.new<float>()
var array<string> trade_directions = array.new<string>()
var array<bool> trade_active = array.new<bool>()

// Reset daily counters
new_day = dayofmonth(time) != current_day
if new_day
    current_day := dayofmonth(time)
    trades_today := 0
    daily_pnl := 0.0

// ============================================================================
// MAIN LOGIC - SWEEP DETECTION & STORAGE
// ============================================================================

// Detect sweep on current bar
[sweep_valid, sweep_type, sweep_price] = detect_liquidity_sweep()

current_trend = detect_trend()

// Store sweep if valid and confirmed bar
if sweep_valid and barstate.isconfirmed
    array.push(sweep_bar_indices, bar_index)
    array.push(sweep_types, sweep_type)
    array.push(sweep_prices, sweep_price)
    array.push(sweep_trends, current_trend)
    array.push(sweep_used, false)
    
    if debug_logging
        log.info("Sweep detected at bar " + str.tostring(bar_index) + ": " + sweep_type + " @ " + str.tostring(sweep_price))
    
    // Show sweep marker
    if show_sweep_markers
        marker_color = sweep_type == "bull_sweep" ? color.green : color.red
        marker_style = sweep_type == "bull_sweep" ? label.style_triangleup : label.style_triangledown
        marker_y = sweep_type == "bull_sweep" ? low : high
        label.new(bar_index, marker_y, "S", color=marker_color, style=marker_style, textcolor=color.white, size=size.tiny)

// Clean up old sweeps (older than lookforward window)
if array.size(sweep_bar_indices) > 0
    for i = array.size(sweep_bar_indices) - 1 to 0
        if bar_index - array.get(sweep_bar_indices, i) > mss_lookforward_bars + 10
            array.remove(sweep_bar_indices, i)
            array.remove(sweep_types, i)
            array.remove(sweep_prices, i)
            array.remove(sweep_trends, i)
            array.remove(sweep_used, i)

// ============================================================================
// MAIN LOGIC - ENTRY SIGNAL GENERATION
// ============================================================================

// Detect FVG on current bar
[fvg_valid, fvg_type, fvg_bottom, fvg_top] = detect_fvg()

// Entry signal variables
var string signal_type = ""
var float entry_price = 0.0
var float sl_price = 0.0
var float tp_price = 0.0
var float used_RR = 0.0
var bool show_signal = false

signal_type := ""
show_signal := false

// Check confluence for entry
if fvg_valid and barstate.isconfirmed and is_trading_session() and trades_today < max_trades_per_day
    
    // Check each recent sweep for MSS confirmation
    if array.size(sweep_bar_indices) > 0
        for i = array.size(sweep_bar_indices) - 1 to 0
            sweep_idx = array.get(sweep_bar_indices, i)
            s_type = array.get(sweep_types, i)
            s_price = array.get(sweep_prices, i)
            s_trend = array.get(sweep_trends, i)
            s_used = array.get(sweep_used, i)
            
            // Skip if already used
            if s_used
                continue
            
            // Skip if too old
            if bar_index - sweep_idx > mss_lookforward_bars
                continue
            
            // Check trend alignment if enabled
            if enable_trend_filter and current_trend != "neutral" and s_trend != current_trend
                continue
            
            // Check if FVG direction matches sweep
            expected_fvg = s_type == "bull_sweep" ? "bullish" : "bearish"
            if fvg_type != expected_fvg
                continue
            
            // Check MSS confirmation
            sweep_low_val = s_type == "bear_sweep" ? s_price : low[bar_index - sweep_idx]
            sweep_high_val = s_type == "bull_sweep" ? s_price : high[bar_index - sweep_idx]
            
            mss_ok = check_mss_after_sweep(sweep_idx, bar_index, s_type, sweep_low_val, sweep_high_val)
            
            if mss_ok
                // Mark sweep as used
                array.set(sweep_used, i, true)
                
                // Calculate entry, SL, TP
                current_RR = get_RR_ratio()
                
                if fvg_type == "bullish"
                    entry_price := fvg_bottom + pips_to_price(spread_pips)
                    sl_price := s_price - pips_to_price(buffer_pips)
                    sl_distance_pips = price_to_pips(entry_price - sl_price)
                    tp_price := entry_price + pips_to_price(sl_distance_pips * current_RR)
                    signal_type := "BUY"
                else
                    entry_price := fvg_top - pips_to_price(spread_pips)
                    sl_price := s_price + pips_to_price(buffer_pips)
                    sl_distance_pips = price_to_pips(sl_price - entry_price)
                    tp_price := entry_price - pips_to_price(sl_distance_pips * current_RR)
                    signal_type := "SELL"
                
                used_RR := current_RR
                show_signal := true
                trades_today += 1
                
                // Store trade for outcome tracking
                array.push(trade_entry_bars, bar_index)
                array.push(trade_entry_prices, entry_price)
                array.push(trade_sl_prices, sl_price)
                array.push(trade_tp_prices, tp_price)
                array.push(trade_directions, signal_type)
                array.push(trade_active, true)
                
                if debug_logging
                    log.info("ENTRY SIGNAL: " + signal_type + " at bar " + str.tostring(bar_index) + ", Entry: " + str.tostring(entry_price) + ", SL: " + str.tostring(sl_price) + ", TP: " + str.tostring(tp_price) + ", RR: " + str.tostring(current_RR, "#.##"))
                
                if show_mss_markers
                    mss_marker_y = fvg_type == "bullish" ? low : high
                    label.new(bar_index, mss_marker_y, "MSS", color=color.blue, style=label.style_circle, textcolor=color.white, size=size.tiny)
                
                break

// ============================================================================
// TRADE OUTCOME TRACKING
// ============================================================================

// Check active trades for TP/SL hits or time-based exit (before NY close)
if array.size(trade_entry_bars) > 0
    for i = array.size(trade_entry_bars) - 1 to 0
        if array.get(trade_active, i)
            entry_bar = array.get(trade_entry_bars, i)
            entry_p = array.get(trade_entry_prices, i)
            sl_p = array.get(trade_sl_prices, i)
            tp_p = array.get(trade_tp_prices, i)
            direction = array.get(trade_directions, i)
            
            // Check if trade should be closed (time-based: before NY close)
            current_h = hour(time)
            bars_in_trade = bar_index - entry_bar
            should_close_time = current_h >= ny_close_hour or bars_in_trade > 30
            
            // Check for TP or SL hit
            tp_hit = false
            sl_hit = false
            
            if direction == "BUY"
                tp_hit := high >= tp_p
                sl_hit := low <= sl_p
            else
                tp_hit := low <= tp_p
                sl_hit := high >= sl_p
            
            // Draw outcome line if trade is complete
            if tp_hit or sl_hit or should_close_time
                array.set(trade_active, i, false)
                exit_bar = bar_index
                exit_price = tp_hit ? tp_p : (sl_hit ? sl_p : close)
                
                // Determine outcome and color
                outcome_color = tp_hit ? color.green : (sl_hit ? color.red : color.orange)
                outcome_text = tp_hit ? "TP✓" : (sl_hit ? "SL✗" : "Exit")
                
                // Draw line from entry to exit
                line.new(entry_bar, entry_p, exit_bar, exit_price, color=outcome_color, width=2, style=line.style_solid)
                
                // Add outcome label at exit
                label.new(exit_bar, exit_price, outcome_text, color=outcome_color, textcolor=color.white, size=size.small, style=label.style_label_left)

// ============================================================================
// VISUAL DISPLAY
// ============================================================================

// Draw FVG box
if fvg_valid and show_fvg_boxes and barstate.isconfirmed
    fvg_color = fvg_type == "bullish" ? color.new(color.green, 85) : color.new(color.red, 85)
    fvg_border = fvg_type == "bullish" ? color.green : color.red
    box.new(bar_index - 2, fvg_top, bar_index + 5, fvg_bottom, border_color=fvg_border, bgcolor=fvg_color, border_width=1)

// Draw Entry Signal
if show_signal
    // Cleaner, smaller signal label (positioned away from candles)
    signal_color = signal_type == "BUY" ? color.new(color.green, 20) : color.new(color.red, 20)
    signal_y = signal_type == "BUY" ? low - (high - low) * 0.3 : high + (high - low) * 0.3
    signal_text = signal_type == "BUY" ? "↑" : "↓"
    label.new(bar_index, signal_y, signal_text, color=signal_color, textcolor=color.white, style=signal_type == "BUY" ? label.style_label_up : label.style_label_down, size=size.small)
    
    // Entry marker at the actual entry price
    label.new(bar_index, entry_price, "E", color=color.blue, textcolor=color.white, size=size.tiny, style=label.style_circle)
    
    // SL and TP markers (smaller, positioned at price levels)
    label.new(bar_index, sl_price, "SL", color=color.red, textcolor=color.white, size=size.tiny, style=label.style_label_left)
    label.new(bar_index, tp_price, "TP", color=color.green, textcolor=color.white, size=size.tiny, style=label.style_label_left)

// ============================================================================
// DASHBOARD DISPLAY
// ============================================================================

// Create simple table for stats
var table stats_table = table.new(position.top_right, 2, 5, border_width=1)

if barstate.islast
    table.cell(stats_table, 0, 0, "Trades Today:", text_color=color.white, bgcolor=color.gray)
    table.cell(stats_table, 1, 0, str.tostring(trades_today), text_color=color.white, bgcolor=color.gray)
    
    table.cell(stats_table, 0, 1, "Session:", text_color=color.white, bgcolor=color.gray)
    session_text = is_trading_session() ? "ACTIVE" : "CLOSED"
    session_color = is_trading_session() ? color.green : color.red
    table.cell(stats_table, 1, 1, session_text, text_color=color.white, bgcolor=session_color)
    
    table.cell(stats_table, 0, 2, "Trend:", text_color=color.white, bgcolor=color.gray)
    table.cell(stats_table, 1, 2, current_trend, text_color=color.white, bgcolor=color.gray)
    
    table.cell(stats_table, 0, 3, "Active Sweeps:", text_color=color.white, bgcolor=color.gray)
    table.cell(stats_table, 1, 3, str.tostring(array.size(sweep_bar_indices)), text_color=color.white, bgcolor=color.gray)
    
    table.cell(stats_table, 0, 4, "Max Daily Loss:", text_color=color.white, bgcolor=color.gray)
    table.cell(stats_table, 1, 4, str.tostring(max_daily_loss_percent, "#.#") + "%", text_color=color.white, bgcolor=color.gray)

// Plot invisible values for strategy tester compatibility
plot(show_signal and signal_type == "BUY" ? 1 : 0, "Buy Signal", display=display.none)
plot(show_signal and signal_type == "SELL" ? 1 : 0, "Sell Signal", display=display.none)
