//+------------------------------------------------------------------+
//|                                                     PivotCandleScalper.mq5
//|  Expert Advisor: PivotCandleScalper
//|  Strategy: Pivot points + Candlestick reversal (Pin Bar / Engulfing)
//|  Designed for M15 (works on any timeframe/symbol, including XAUUSD)
//|  Author: Generated by assistant (samiabat request)
//+------------------------------------------------------------------+
#property copyright "PivotCandleScalper"
#property version   "1.00"
#property strict

#include <Trade\Trade.mqh>

//---- Input parameters
input double LotSize           = 0.01;      // Fixed lot size (ignored if RiskPercent > 0)
input double RiskPercent       = 0.5;       // Percent of account balance to risk (0 = disabled)
input double StopLossPips      = 15.0;      // SL in pips
input double TakeProfit1Pips   = 20.0;      // First TP in pips
input double TakeProfit2Pips   = 40.0;      // Second TP in pips
input long   MagicNumber       = 202506;    // Magic number for EA trades
input double MaxSpread         = 30.0;      // Max spread in points
input bool   EnableTradingHours= false;     // Restrict trading to hours?
input int    TradeStartHour    = 0;         // Trading start hour (server)
input int    TradeEndHour      = 23;        // Trading end hour (server)

//---- Global objects & variables
CTrade trade;
datetime lastSignalTime = 0; // to ensure only one trade per signal candle

//---- Helper function: round lot to allowed step
double NormalizeLot(double lot)
{
   double minLot = SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MIN);
   double maxLot = SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MAX);
   double step   = SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_STEP);
   if(step <= 0 || minLot <= 0) return(MathMax(minLot,lot));
   // clamp
   if(lot < minLot) lot = minLot;
   if(lot > maxLot) lot = maxLot;
   // normalize to step
   double steps = MathFloor((lot - minLot)/step + 0.0000001);
   double normalized = minLot + steps * step;
   // ensure not less than min
   if(normalized < minLot) normalized = minLot;
   // check upper bound
   if(normalized > maxLot) normalized = maxLot;
   // round to 8 decimals safe
   return(NormalizeDouble(normalized,8));
}

//---- Helper: get previous daily OHLC (previous trading day)
bool GetPreviousDayOHLC(double &prevHigh,double &prevLow,double &prevClose)
{
   // Use D1 timeframe, bar shift 1 = previous completed day
   int copied;
   double highs[], lows[], closes[];
   copied = CopyHigh(_Symbol, PERIOD_D1, 1, 1, highs);
   if(copied != 1) return(false);
   copied = CopyLow(_Symbol, PERIOD_D1, 1, 1, lows);
   if(copied != 1) return(false);
   copied = CopyClose(_Symbol, PERIOD_D1, 1, 1, closes);
   if(copied != 1) return(false);
   prevHigh = highs[0];
   prevLow  = lows[0];
   prevClose= closes[0];
   return(true);
}

//---- Pivot calculation (standard pivots)
void CalculatePivots(double &PP,double &R1,double &R2,double &S1,double &S2)
{
   double H,L,C;
   if(!GetPreviousDayOHLC(H,L,C))
   {
      // fallback to today's values if previous day not found
      H = iHigh(_Symbol,PERIOD_D1,1);
      L = iLow(_Symbol,PERIOD_D1,1);
      C = iClose(_Symbol,PERIOD_D1,1);
   }
   PP = (H + L + C)/3.0;
   R1 = 2.0*PP - L;
   S1 = 2.0*PP - H;
   R2 = PP + (H - L);
   S2 = PP - (H - L);
}

//---- Candlestick helpers
// Single-line function definitions for header (user warned against multiline in header)
double CandleBodySize(int shift) { return(MathAbs(iClose(_Symbol,Period(),shift) - iOpen(_Symbol,Period(),shift))); }
double CandleHigh(int shift)    { return(iHigh(_Symbol,Period(),shift)); }
double CandleLow(int shift)     { return(iLow(_Symbol,Period(),shift)); }
double CandleOpen(int shift)    { return(iOpen(_Symbol,Period(),shift)); }
double CandleClose(int shift)   { return(iClose(_Symbol,Period(),shift)); }

//---- Pin Bar detection
bool IsBullishPinBar(int shift)
{
   double open  = CandleOpen(shift);
   double close = CandleClose(shift);
   double high  = CandleHigh(shift);
   double low   = CandleLow(shift);
   double body  = MathAbs(close - open);
   double upperWick = high - MathMax(open, close);
   double lowerWick = MathMin(open, close) - low;
   double totalRange = high - low;
   if(totalRange <= 0.0) return(false);
   // small body check (not zero)
   if(body <= 0.0) return(false);
   // bullish body
   if(close <= open) return(false);
   // Lower wick (nose) >= 2x body
   if(lowerWick < 2.0 * body) return(false);
   // Opposite wick <= 30% of total range
   if(upperWick > 0.3 * totalRange) return(false);
   return(true);
}

bool IsBearishPinBar(int shift)
{
   double open  = CandleOpen(shift);
   double close = CandleClose(shift);
   double high  = CandleHigh(shift);
   double low   = CandleLow(shift);
   double body  = MathAbs(close - open);
   double upperWick = high - MathMax(open, close);
   double lowerWick = MathMin(open, close) - low;
   double totalRange = high - low;
   if(totalRange <= 0.0) return(false);
   if(body <= 0.0) return(false);
   // bearish body
   if(close >= open) return(false);
   // Upper wick >= 2x body
   if(upperWick < 2.0 * body) return(false);
   // Opposite wick <= 30% of total range
   if(lowerWick > 0.3 * totalRange) return(false);
   return(true);
}

//---- Engulfing detection (current fully engulfs previous body's open-close)
bool IsBullishEngulfing(int shift)
{
   // current candle at 'shift', previous at 'shift+1'
   double curOpen  = CandleOpen(shift);
   double curClose = CandleClose(shift);
   double prevOpen = CandleOpen(shift+1);
   double prevClose= CandleClose(shift+1);
   if(curClose <= curOpen) return(false); // current must be bullish
   // Current body engulfs previous body
   double curLowBody  = MathMin(curOpen, curClose);
   double curHighBody = MathMax(curOpen, curClose);
   double prevLowBody = MathMin(prevOpen, prevClose);
   double prevHighBody= MathMax(prevOpen, prevClose);
   if(curLowBody <= prevLowBody && curHighBody >= prevHighBody) return(true);
   return(false);
}

bool IsBearishEngulfing(int shift)
{
   double curOpen  = CandleOpen(shift);
   double curClose = CandleClose(shift);
   double prevOpen = CandleOpen(shift+1);
   double prevClose= CandleClose(shift+1);
   if(curClose >= curOpen) return(false); // current must be bearish
   double curLowBody  = MathMin(curOpen, curClose);
   double curHighBody = MathMax(curOpen, curClose);
   double prevLowBody = MathMin(prevOpen, prevClose);
   double prevHighBody= MathMax(prevOpen, prevClose);
   if(curLowBody <= prevLowBody && curHighBody >= prevHighBody) return(true);
   return(false);
}

//---- Check existing position with same MagicNumber
bool HasOpenPositionWithMagic()
{
   int total = PositionsTotal();
   for(int i=0;i<total;i++)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket==0) continue;
      if(!PositionSelectByTicket(ticket)) continue;
      string sym = PositionGetString(POSITION_SYMBOL);
      long mag = PositionGetInteger(POSITION_MAGIC);
      if(sym==_Symbol && mag==MagicNumber) return(true);
   }
   return(false);
}

//---- Send market order (uses MqlTradeRequest)
bool SendMarketOrder(bool isBuy, double volume, double slPrice, string comment)
{
   MqlTradeRequest request;
   MqlTradeResult  result;
   ZeroMemory(request);
   ZeroMemory(result);

   request.action = TRADE_ACTION_DEAL;
   request.symbol = _Symbol;
   request.volume = volume;
   request.deviation = 10;
   request.type_filling = ORDER_FILLING_FOK;
   request.tp = 0;
   request.sl = 0;
   request.price = isBuy ? SymbolInfoDouble(_Symbol,SYMBOL_ASK) : SymbolInfoDouble(_Symbol,SYMBOL_BID);
   request.type = isBuy ? ORDER_TYPE_BUY : ORDER_TYPE_SELL;
   request.magic = MagicNumber;
   request.comment = comment;
   if(slPrice > 0.0) request.sl = slPrice;

   if(!OrderSend(request,result))
   {
      PrintFormat("OrderSend failed: retcode=%d comment=%s", result.retcode, result.comment);
      return(false);
   }
   if(result.retcode != TRADE_RETCODE_DONE && result.retcode != TRADE_RETCODE_DONE_REMAINDER)
   {
      PrintFormat("Market order not done. retcode=%d comment=%s", result.retcode, result.comment);
      return(false);
   }
   // success
   PrintFormat("Market order placed: ticket=%I64u type=%s volume=%.2f price=%.5f",
               result.order, isBuy ? "BUY" : "SELL", volume, request.price);
   return(true);
}

//---- Send pending order (limit used to close part of the position later)
bool SendPendingOrder(int order_type, double price, double volume, datetime expiration, string comment)
{
   MqlTradeRequest request;
   MqlTradeResult  result;
   ZeroMemory(request);
   ZeroMemory(result);

   request.action = TRADE_ACTION_PENDING;
   request.symbol = _Symbol;
   request.volume = volume;
   request.price = price;
   request.deviation = 10;
   request.type = order_type;
   request.pending = order_type; // not strictly needed, but set
   request.type_filling = ORDER_FILLING_IOC;
   request.type_time = ORDER_TIME_SPECIFIED;
   request.expiration = expiration;
   request.magic = MagicNumber;
   request.comment = comment;
   // No TP/SL for pending close orders; they serve to close portions
   if(!OrderSend(request,result))
   {
      PrintFormat("Pending OrderSend failed: retcode=%d comment=%s", result.retcode, result.comment);
      return(false);
   }
   if(result.retcode != TRADE_RETCODE_DONE && result.retcode != TRADE_RETCODE_PLACED)
   {
      PrintFormat("Pending order not placed. retcode=%d comment=%s", result.retcode, result.comment);
      return(false);
   }
   PrintFormat("Pending order placed: ticket=%I64u type=%d vol=%.2f price=%.5f", result.order, order_type, volume, price);
   return(true);
}

//---- Time window check
bool IsWithinTradingHours()
{
   if(!EnableTradingHours) return(true);
   int hour = TimeHour(TimeCurrent());
   if(TradeStartHour <= TradeEndHour)
      return(hour >= TradeStartHour && hour <= TradeEndHour);
   else
      // wrap-around (e.g., start 22 end 6)
      return(hour >= TradeStartHour || hour <= TradeEndHour);
}

//---- Compute dynamic lot by risk percent
double CalculateLotByRisk(bool isBuy, double entryPrice, double slPrice)
{
   if(RiskPercent <= 0.0) return(NormalizeLot(LotSize));
   double tickSize = SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_SIZE);
   double tickValue= SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_VALUE);
   double point = SymbolInfoDouble(_Symbol,SYMBOL_POINT);
   if(point <= 0.0) point = _Point;
   double slDistance = MathAbs(entryPrice - slPrice); // price units
   if(slDistance <= 0.0) return(NormalizeLot(LotSize));
   // If tickValue or tickSize are zero, fallback to approximate calculation:
   double riskMoney = AccountInfoDouble(ACCOUNT_BALANCE) * (RiskPercent/100.0);
   double riskPerLot;
   if(tickValue > 0.0 && tickSize > 0.0)
   {
      // number of ticks in SL = slDistance / tickSize
      double ticks = slDistance / tickSize;
      riskPerLot = ticks * tickValue;
      if(riskPerLot <= 0.0) return(NormalizeLot(LotSize));
      double lot = riskMoney / riskPerLot;
      return NormalizeLot(lot);
   }
   // fallback method: approximate using point and contract size (may be inaccurate on some symbols)
   double contractSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_CONTRACT_SIZE);
   if(contractSize <= 0.0) contractSize = 100000.0; // fallback
   // approximate value movement per 1 lot per 1 point:
   double valuePerPoint = contractSize * point;
   if(valuePerPoint <= 0.0) return(NormalizeLot(LotSize));
   double lot = riskMoney / (slDistance / point * valuePerPoint);
   return NormalizeLot(lot);
}

//---- Proximity helper: returns true if price is within threshold (in pips) of level
bool IsPriceNearLevel(double price, double level, double thresholdPips, double pipSize)
{
   double diff = MathAbs(price - level);
   return(diff <= thresholdPips * pipSize);
}

//---- Main check & trade logic executed on tick
void CheckAndTrade()
{
   // respect trading hours
   if(!IsWithinTradingHours()) return;

   // check spread
   double ask = SymbolInfoDouble(_Symbol,SYMBOL_ASK);
   double bid = SymbolInfoDouble(_Symbol,SYMBOL_BID);
   double point = SymbolInfoDouble(_Symbol,SYMBOL_POINT);
   if(point <= 0.0) point = _Point;
   double spreadPoints = (ask - bid) / point;
   if(spreadPoints > MaxSpread)
   {
      // too wide spread
      //PrintFormat("Spread too wide: %.1f points (max %.1f)", spreadPoints, MaxSpread);
      return;
   }

   // check if we already have a position with this magic
   if(HasOpenPositionWithMagic()) return;

   // use the last closed M15 candle (shift=1). Ensure we only process each closed candle once.
   int signalShift = 1;
   datetime candleCloseTime = iTime(_Symbol,Period(),signalShift);
   if(candleCloseTime == 0) return;
   if(candleCloseTime == lastSignalTime) return; // already processed
   // record to prevent multi-processing within same candle
   lastSignalTime = candleCloseTime;

   // Calculate pivots using previous daily OHLC
   double PP,R1,R2,S1,S2;
   CalculatePivots(PP,R1,R2,S1,S2);

   // Current price (use mid)
   double currentPrice = (ask + bid)/2.0;

   // determine bias
   bool bullishBias = (currentPrice > PP);
   bool bearishBias = (currentPrice < PP);

   // pip size: convert user "pips" to price units. For 5-digit brokers pip usually = 10 * point
   int digits = (int)SymbolInfoInteger(_Symbol,SYMBOL_DIGITS);
   double pipSize = point * ((digits==3 || digits==5) ? 10.0 : 1.0);

   // proximity threshold to consider level touched/pullback
   double proximityPips = MathMax(3.0, StopLossPips/2.0);

   // check closed candle patterns at signalShift
   bool bullishPin = IsBullishPinBar(signalShift);
   bool bearishPin = IsBearishPinBar(signalShift);
   bool bullishEngulf = IsBullishEngulfing(signalShift);
   bool bearishEngulf = IsBearishEngulfing(signalShift);

   double sigOpen  = CandleOpen(signalShift);
   double sigClose = CandleClose(signalShift);
   double sigHigh  = CandleHigh(signalShift);
   double sigLow   = CandleLow(signalShift);

   // Evaluate long entry conditions
   if(bullishBias)
   {
      // require pattern bullish and near S1 or PP
      bool pattern = (bullishPin || bullishEngulf);
      bool nearS1 = IsPriceNearLevel(sigClose, S1, proximityPips, pipSize) || IsPriceNearLevel(sigLow, S1, proximityPips, pipSize);
      bool nearPP = IsPriceNearLevel(sigClose, PP, proximityPips, pipSize) || IsPriceNearLevel(sigLow, PP, proximityPips, pipSize);
      if(pattern && (nearS1 || nearPP))
      {
         // compute entry, SL, TP
         double entry = ask; // market buy at ask
         double sl = sigLow - 3.0 * point; // SL below signal candle low with a small buffer
         double tp1 = entry + TakeProfit1Pips * pipSize;
         double tp2 = entry + TakeProfit2Pips * pipSize;
         // compute lot size
         double lot = CalculateLotByRisk(true, entry, sl);
         if(lot < SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MIN)) lot = SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MIN);
         lot = NormalizeLot(lot);
         if(lot <= 0)
         {
            Print("Calculated lot <= 0, aborting trade.");
            return;
         }
         // send market buy
         if(!SendMarketOrder(true, lot, sl, "PCS BUY")) return;
         // after opening, place two SELL_LIMIT pending orders to take partial profits
         // volumes: 50% and remaining 50%
         double vol1 = NormalizeDouble(lot/2.0,2);
         double vol2 = lot - vol1;
         if(vol1 < SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MIN)) vol1 = SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MIN);
         if(vol2 < SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MIN)) vol2 = SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MIN);
         datetime exp = TimeCurrent() + 7*24*3600; // pending orders expire in 7 days
         // SELL_LIMIT at TP1 and TP2 (above current price)
         SendPendingOrder(ORDER_TYPE_SELL_LIMIT, tp1, vol1, exp, "PCS TP1");
         SendPendingOrder(ORDER_TYPE_SELL_LIMIT, tp2, vol2, exp, "PCS TP2");
      }
   }

   // Evaluate short entry conditions
   if(bearishBias)
   {
      // require bearish pattern and near R1 or PP
      bool pattern = (bearishPin || bearishEngulf);
      bool nearR1 = IsPriceNearLevel(sigClose, R1, proximityPips, pipSize) || IsPriceNearLevel(sigHigh, R1, proximityPips, pipSize);
      bool nearPP = IsPriceNearLevel(sigClose, PP, proximityPips, pipSize) || IsPriceNearLevel(sigHigh, PP, proximityPips, pipSize);
      if(pattern && (nearR1 || nearPP))
      {
         double entry = bid; // market sell at bid
         double sl = sigHigh + 3.0 * point; // SL above signal candle high
         double tp1 = entry - TakeProfit1Pips * pipSize;
         double tp2 = entry - TakeProfit2Pips * pipSize;
         double lot = CalculateLotByRisk(false, entry, sl);
         if(lot < SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MIN)) lot = SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MIN);
         lot = NormalizeLot(lot);
         if(lot <= 0)
         {
            Print("Calculated lot <= 0, aborting trade.");
            return;
         }
         if(!SendMarketOrder(false, lot, sl, "PCS SELL")) return;
         double vol1 = NormalizeDouble(lot/2.0,2);
         double vol2 = lot - vol1;
         if(vol1 < SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MIN)) vol1 = SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MIN);
         if(vol2 < SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MIN)) vol2 = SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MIN);
         datetime exp = TimeCurrent() + 7*24*3600;
         // BUY_LIMIT pending orders at TP1 and TP2 (below current price) to close short position
         SendPendingOrder(ORDER_TYPE_BUY_LIMIT, tp1, vol1, exp, "PCS TP1");
         SendPendingOrder(ORDER_TYPE_BUY_LIMIT, tp2, vol2, exp, "PCS TP2");
      }
   }
}

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{
   // validate symbol trading availability
   if(!SymbolInfoInteger(_Symbol,SYMBOL_SELECT))
   {
      bool sel = SymbolSelect(_Symbol,true);
      if(!sel)
      {
         Print("Failed to select symbol: ", _Symbol);
         return(INIT_FAILED);
      }
   }
   // initial checks
   Print("PivotCandleScalper initialized for ", _Symbol, " timeframe=", EnumToString(Period()));
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   Print("PivotCandleScalper stopped.");
}

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
{
   // Main loop - check and trade upon each tick
   CheckAndTrade();
}

//+------------------------------------------------------------------+
//| Utility: convert period enum to string (for debug)               |
//+------------------------------------------------------------------+
string EnumToString(int p)
{
   switch(p)
   {
      case PERIOD_M1:   return "M1";
      case PERIOD_M5:   return "M5";
      case PERIOD_M15:  return "M15";
      case PERIOD_M30:  return "M30";
      case PERIOD_H1:   return "H1";
      case PERIOD_H4:   return "H4";
      case PERIOD_D1:   return "D1";
      case PERIOD_W1:   return "W1";
      case PERIOD_MN1:  return "MN1";
      default: return "UNKNOWN";
   }
}
//+------------------------------------------------------------------+
