//@version=5
indicator("ICT Concepts Indicator", overlay=true, max_boxes_count=500, max_lines_count=500)

// ============================================================================
// INPUT PARAMETERS
// ============================================================================

// Order Block Settings
obLookback = input.int(20, "Order Block Lookback", minval=5, maxval=100)
obMinSize = input.float(0.0001, "Min Order Block Size", minval=0.0001)

// Fair Value Gap Settings
fvgLookback = input.int(3, "FVG Lookback", minval=3, maxval=10)
fvgMinSize = input.float(0.0001, "Min FVG Size", minval=0.0001)

// Market Structure Settings
msLookback = input.int(10, "Market Structure Lookback", minval=5, maxval=50)

// Display Settings
showOrderBlocks = input.bool(true, "Show Order Blocks")
showFVG = input.bool(true, "Show Fair Value Gaps")
showSignals = input.bool(true, "Show Buy/Sell Signals")

// Colors
bullishColor = input.color(color.new(color.green, 80), "Bullish Zone Color")
bearishColor = input.color(color.new(color.red, 80), "Bearish Zone Color")

// ============================================================================
// ZONE TRACKING ARRAYS - Prevent Overlapping
// ============================================================================

// Type definitions for tracking zones
type Zone
    float top
    float bottom
    int startBar
    int endBar
    bool isBullish

// Arrays to store active zones (non-overlapping)
var array<Zone> activeOrderBlocks = array.new<Zone>()
var array<Zone> activeFVGs = array.new<Zone>()

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

// Check if two zones overlap
zonesOverlap(float top1, float bottom1, float top2, float bottom2) =>
    not (top1 < bottom2 or top2 < bottom1)

// Check if price range overlaps with any existing zones in an array
hasOverlap(array<Zone> zones, float top, float bottom) =>
    overlap = false
    if array.size(zones) > 0
        for i = 0 to array.size(zones) - 1
            zone = array.get(zones, i)
            if zonesOverlap(top, bottom, zone.top, zone.bottom)
                overlap := true
                break
    overlap

// Add zone to array if it doesn't overlap
addZoneIfNoOverlap(array<Zone> zones, float top, float bottom, bool isBullish, int maxZones = 50) =>
    if not hasOverlap(zones, top, bottom)
        // Remove oldest zone if we've reached the limit
        if array.size(zones) >= maxZones
            array.shift(zones)
        
        // Add new zone
        newZone = Zone.new(
             top = top,
             bottom = bottom,
             startBar = bar_index,
             endBar = bar_index + 50,
             isBullish = isBullish
         )
        array.push(zones, newZone)
        true
    else
        false

// Clean up old zones that are no longer relevant
cleanOldZones(array<Zone> zones, int maxBars = 100) =>
    if array.size(zones) > 0
        for i = array.size(zones) - 1 to 0
            zone = array.get(zones, i)
            if bar_index - zone.startBar > maxBars
                array.remove(zones, i)

// ============================================================================
// ORDER BLOCK DETECTION
// ============================================================================

// Bullish Order Block: Last down candle before strong up move
detectBullishOrderBlock() =>
    obTop = 0.0
    obBottom = 0.0
    found = false
    
    // Look for a down candle followed by strong bullish movement
    if close[obLookback] < open[obLookback]  // Down candle
        upwardMomentum = 0.0
        
        // Check for bullish movement in subsequent candles
        for i = obLookback - 1 to 0
            if close[i] > close[i + 1]
                upwardMomentum += close[i] - close[i + 1]
        
        // If significant upward movement detected
        if upwardMomentum > (high[obLookback] - low[obLookback]) * 2
            obTop := high[obLookback]
            obBottom := low[obLookback]
            
            // Ensure minimum size
            if (obTop - obBottom) > obMinSize
                found := true
    
    [found, obTop, obBottom]

// Bearish Order Block: Last up candle before strong down move
detectBearishOrderBlock() =>
    obTop = 0.0
    obBottom = 0.0
    found = false
    
    // Look for an up candle followed by strong bearish movement
    if close[obLookback] > open[obLookback]  // Up candle
        downwardMomentum = 0.0
        
        // Check for bearish movement in subsequent candles
        for i = obLookback - 1 to 0
            if close[i] < close[i + 1]
                downwardMomentum += close[i + 1] - close[i]
        
        // If significant downward movement detected
        if downwardMomentum > (high[obLookback] - low[obLookback]) * 2
            obTop := high[obLookback]
            obBottom := low[obLookback]
            
            // Ensure minimum size
            if (obTop - obBottom) > obMinSize
                found := true
    
    [found, obTop, obBottom]

// ============================================================================
// FAIR VALUE GAP (FVG) DETECTION
// ============================================================================

// Bullish FVG: Gap between candle[2] high and current candle low
detectBullishFVG() =>
    fvgTop = 0.0
    fvgBottom = 0.0
    found = false
    
    // Bullish FVG: low[0] > high[2] (gap up)
    if low[0] > high[2]
        gap = low[0] - high[2]
        
        // Ensure minimum gap size
        if gap > fvgMinSize
            fvgTop := low[0]
            fvgBottom := high[2]
            found := true
    
    [found, fvgTop, fvgBottom]

// Bearish FVG: Gap between candle[2] low and current candle high
detectBearishFVG() =>
    fvgTop = 0.0
    fvgBottom = 0.0
    found = false
    
    // Bearish FVG: high[0] < low[2] (gap down)
    if high[0] < low[2]
        gap = low[2] - high[0]
        
        // Ensure minimum gap size
        if gap > fvgMinSize
            fvgTop := low[2]
            fvgBottom := high[0]
            found := true
    
    [found, fvgTop, fvgBottom]

// ============================================================================
// MARKET STRUCTURE ANALYSIS
// ============================================================================

// Detect Higher High (HH)
isHigherHigh() =>
    highestInRange = ta.highest(high, msLookback)
    high == highestInRange and high > high[msLookback]

// Detect Lower Low (LL)
isLowerLow() =>
    lowestInRange = ta.lowest(low, msLookback)
    low == lowestInRange and low < low[msLookback]

// Detect market structure shift
var int lastStructure = 0  // 1 for bullish, -1 for bearish, 0 for neutral
var bool structureShift = false

if isHigherHigh()
    if lastStructure != 1
        structureShift := true
    lastStructure := 1
else if isLowerLow()
    if lastStructure != -1
        structureShift := true
    lastStructure := -1
else
    structureShift := false

// ============================================================================
// SIGNAL GENERATION (Prevent Simultaneous Buy/Sell)
// ============================================================================

var int lastSignal = 0  // 1 for buy, -1 for sell, 0 for none
var int lastSignalBar = 0

// Buy Signal Logic
buySignal = false
sellSignal = false

// Check for bullish setups
[foundBullOB, bullOBTop, bullOBBottom] = detectBullishOrderBlock()
[foundBullFVG, bullFVGTop, bullFVGBottom] = detectBullishFVG()

// Check for bearish setups
[foundBearOB, bearOBTop, bearOBBottom] = detectBearishOrderBlock()
[foundBearFVG, bearFVGTop, bearFVGBottom] = detectBearishFVG()

// Generate buy signal only if:
// 1. Bullish setup detected
// 2. No sell signal at the same location
// 3. Market structure supports it
if (foundBullOB or foundBullFVG) and lastStructure >= 0 and not (foundBearOB or foundBearFVG)
    if lastSignal != 1 or bar_index - lastSignalBar > 5
        buySignal := true
        lastSignal := 1
        lastSignalBar := bar_index

// Generate sell signal only if:
// 1. Bearish setup detected
// 2. No buy signal at the same location
// 3. Market structure supports it
if (foundBearOB or foundBearFVG) and lastStructure <= 0 and not (foundBullOB or foundBullFVG)
    if lastSignal != -1 or bar_index - lastSignalBar > 5
        sellSignal := true
        lastSignal := -1
        lastSignalBar := bar_index

// ============================================================================
// ADD ZONES TO TRACKING ARRAYS (Non-overlapping)
// ============================================================================

// Clean old zones periodically
if bar_index % 10 == 0
    cleanOldZones(activeOrderBlocks)
    cleanOldZones(activeFVGs)

// Add Order Blocks
if foundBullOB and showOrderBlocks
    addZoneIfNoOverlap(activeOrderBlocks, bullOBTop, bullOBBottom, true)

if foundBearOB and showOrderBlocks
    addZoneIfNoOverlap(activeOrderBlocks, bearOBTop, bearOBBottom, false)

// Add Fair Value Gaps
if foundBullFVG and showFVG
    addZoneIfNoOverlap(activeFVGs, bullFVGTop, bullFVGBottom, true)

if foundBearFVG and showFVG
    addZoneIfNoOverlap(activeFVGs, bearFVGTop, bearFVGBottom, false)

// ============================================================================
// VISUALIZATION
// ============================================================================

// Draw Order Blocks
if showOrderBlocks and array.size(activeOrderBlocks) > 0
    for i = 0 to array.size(activeOrderBlocks) - 1
        zone = array.get(activeOrderBlocks, i)
        if bar_index <= zone.endBar
            box.new(
                 zone.startBar, zone.top, bar_index, zone.bottom,
                 border_color = zone.isBullish ? color.green : color.red,
                 bgcolor = zone.isBullish ? bullishColor : bearishColor,
                 border_width = 1
             )

// Draw Fair Value Gaps
if showFVG and array.size(activeFVGs) > 0
    for i = 0 to array.size(activeFVGs) - 1
        zone = array.get(activeFVGs, i)
        if bar_index <= zone.endBar
            box.new(
                 zone.startBar, zone.top, bar_index, zone.bottom,
                 border_color = zone.isBullish ? color.new(color.green, 50) : color.new(color.red, 50),
                 bgcolor = zone.isBullish ? color.new(color.green, 90) : color.new(color.red, 90),
                 border_width = 1,
                 border_style = line.style_dashed
             )

// Plot Buy/Sell Signals
plotshape(
     buySignal and showSignals, 
     title="Buy Signal", 
     location=location.belowbar, 
     color=color.green, 
     style=shape.labelup, 
     text="BUY",
     textcolor=color.white,
     size=size.small
 )

plotshape(
     sellSignal and showSignals, 
     title="Sell Signal", 
     location=location.abovebar, 
     color=color.red, 
     style=shape.labeldown, 
     text="SELL",
     textcolor=color.white,
     size=size.small
 )

// Alert conditions
alertcondition(buySignal, title="ICT Buy Signal", message="ICT Buy Signal Detected")
alertcondition(sellSignal, title="ICT Sell Signal", message="ICT Sell Signal Detected")
