//@version=5
strategy("ICT Strategy Tester", overlay=true, max_boxes_count=500, max_lines_count=500, 
         default_qty_type=strategy.percent_of_equity, default_qty_value=10,
         initial_capital=10000, commission_type=strategy.commission.percent, commission_value=0.1)

// ============================================================================
// INPUT PARAMETERS
// ============================================================================

// Order Block Settings
obLookback = input.int(20, "Order Block Lookback", minval=5, maxval=100)
obMinSize = input.float(0.0001, "Min Order Block Size", minval=0.0001)

// Fair Value Gap Settings
fvgLookback = input.int(3, "FVG Lookback", minval=3, maxval=10)
fvgMinSize = input.float(0.0001, "Min FVG Size", minval=0.0001)

// Market Structure Settings
msLookback = input.int(10, "Market Structure Lookback", minval=5, maxval=50)

// Trade Management Settings
minBarsBetweenTrades = input.int(5, "Min Bars Between Trades", minval=1, maxval=50, 
                                 tooltip="Prevent consecutive trades within this many bars")
maxTradesPerDay = input.int(5, "Max Trades Per Day", minval=1, maxval=20,
                            tooltip="Maximum number of trades allowed in a single day")

// Stop Loss and Take Profit
stopLossPercent = input.float(1.5, "Stop Loss %", minval=0.1, maxval=10.0, step=0.1)
takeProfitPercent = input.float(3.0, "Take Profit %", minval=0.1, maxval=20.0, step=0.1)

// Display Settings
showOrderBlocks = input.bool(true, "Show Order Blocks")
showFVG = input.bool(true, "Show Fair Value Gaps")

// Colors
bullishColor = input.color(color.new(color.green, 80), "Bullish Zone Color")
bearishColor = input.color(color.new(color.red, 80), "Bearish Zone Color")

// ============================================================================
// TRADE TRACKING VARIABLES
// ============================================================================

// Track last trade bar to enforce minimum spacing
var int lastTradeBar = 0

// Track daily trade count
var int currentDay = 0
var int dailyTradeCount = 0

// Reset daily counter when new day starts
newDay = ta.change(dayofweek) != 0 or ta.change(year) != 0 or ta.change(month) != 0
if newDay
    currentDay := dayofweek
    dailyTradeCount := 0

// ============================================================================
// ZONE TRACKING ARRAYS - Prevent Overlapping
// ============================================================================

// Type definitions for tracking zones
type Zone
    float top
    float bottom
    int startBar
    int endBar
    bool isBullish

// Arrays to store active zones (non-overlapping)
var array<Zone> activeOrderBlocks = array.new<Zone>()
var array<Zone> activeFVGs = array.new<Zone>()

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

// Check if two zones overlap
zonesOverlap(float top1, float bottom1, float top2, float bottom2) =>
    not (top1 < bottom2 or top2 < bottom1)

// Check if price range overlaps with any existing zones in an array
hasOverlap(array<Zone> zones, float top, float bottom) =>
    overlap = false
    if array.size(zones) > 0
        for i = 0 to array.size(zones) - 1
            zone = array.get(zones, i)
            if zonesOverlap(top, bottom, zone.top, zone.bottom)
                overlap := true
                break
    overlap

// Add zone to array if it doesn't overlap
addZoneIfNoOverlap(array<Zone> zones, float top, float bottom, bool isBullish, int maxZones = 50) =>
    if not hasOverlap(zones, top, bottom)
        // Remove oldest zone if we've reached the limit
        if array.size(zones) >= maxZones
            array.shift(zones)
        
        // Add new zone
        newZone = Zone.new(
             top = top,
             bottom = bottom,
             startBar = bar_index,
             endBar = bar_index + 50,
             isBullish = isBullish
         )
        array.push(zones, newZone)
        true
    else
        false

// Clean up old zones that are no longer relevant
cleanOldZones(array<Zone> zones, int maxBars = 100) =>
    if array.size(zones) > 0
        for i = array.size(zones) - 1 to 0
            zone = array.get(zones, i)
            if bar_index - zone.startBar > maxBars
                array.remove(zones, i)

// ============================================================================
// ORDER BLOCK DETECTION
// ============================================================================

// Bullish Order Block: Last down candle before strong up move
detectBullishOrderBlock() =>
    obTop = 0.0
    obBottom = 0.0
    found = false
    
    // Look for a down candle followed by strong bullish movement
    if close[obLookback] < open[obLookback]  // Down candle
        bullishMove = false
        upwardMomentum = 0.0
        
        // Check for bullish movement in subsequent candles
        for i = obLookback - 1 to 0
            if close[i] > close[i + 1]
                upwardMomentum += close[i] - close[i + 1]
        
        // If significant upward movement detected
        if upwardMomentum > (high[obLookback] - low[obLookback]) * 2
            obTop := high[obLookback]
            obBottom := low[obLookback]
            
            // Ensure minimum size
            if (obTop - obBottom) > obMinSize
                found := true
    
    [found, obTop, obBottom]

// Bearish Order Block: Last up candle before strong down move
detectBearishOrderBlock() =>
    obTop = 0.0
    obBottom = 0.0
    found = false
    
    // Look for an up candle followed by strong bearish movement
    if close[obLookback] > open[obLookback]  // Up candle
        bearishMove = false
        downwardMomentum = 0.0
        
        // Check for bearish movement in subsequent candles
        for i = obLookback - 1 to 0
            if close[i] < close[i + 1]
                downwardMomentum += close[i + 1] - close[i]
        
        // If significant downward movement detected
        if downwardMomentum > (high[obLookback] - low[obLookback]) * 2
            obTop := high[obLookback]
            obBottom := low[obLookback]
            
            // Ensure minimum size
            if (obTop - obBottom) > obMinSize
                found := true
    
    [found, obTop, obBottom]

// ============================================================================
// FAIR VALUE GAP (FVG) DETECTION
// ============================================================================

// Bullish FVG: Gap between candle[2] high and current candle low
detectBullishFVG() =>
    fvgTop = 0.0
    fvgBottom = 0.0
    found = false
    
    // Bullish FVG: low[0] > high[2] (gap up)
    if low[0] > high[2]
        gap = low[0] - high[2]
        
        // Ensure minimum gap size
        if gap > fvgMinSize
            fvgTop := low[0]
            fvgBottom := high[2]
            found := true
    
    [found, fvgTop, fvgBottom]

// Bearish FVG: Gap between candle[2] low and current candle high
detectBearishFVG() =>
    fvgTop = 0.0
    fvgBottom = 0.0
    found = false
    
    // Bearish FVG: high[0] < low[2] (gap down)
    if high[0] < low[2]
        gap = low[2] - high[0]
        
        // Ensure minimum gap size
        if gap > fvgMinSize
            fvgTop := low[2]
            fvgBottom := high[0]
            found := true
    
    [found, fvgTop, fvgBottom]

// ============================================================================
// MARKET STRUCTURE ANALYSIS
// ============================================================================

// Detect Higher High (HH)
isHigherHigh() =>
    highestInRange = ta.highest(high, msLookback)
    high == highestInRange and high > high[msLookback]

// Detect Lower Low (LL)
isLowerLow() =>
    lowestInRange = ta.lowest(low, msLookback)
    low == lowestInRange and low < low[msLookback]

// Detect market structure shift
var int lastStructure = 0  // 1 for bullish, -1 for bearish, 0 for neutral
var bool structureShift = false

if isHigherHigh()
    if lastStructure != 1
        structureShift := true
    lastStructure := 1
else if isLowerLow()
    if lastStructure != -1
        structureShift := true
    lastStructure := -1
else
    structureShift := false

// ============================================================================
// TRADE LIMITING LOGIC
// ============================================================================

// Check if we can take a new trade based on:
// 1. Minimum bars between trades
// 2. Maximum daily trades limit
canTakeTrade() =>
    barsSinceLastTrade = bar_index - lastTradeBar
    barsCondition = barsSinceLastTrade >= minBarsBetweenTrades
    dailyCondition = dailyTradeCount < maxTradesPerDay
    
    // Both conditions must be met
    barsCondition and dailyCondition

// ============================================================================
// SIGNAL GENERATION (Prevent Simultaneous Buy/Sell)
// ============================================================================

var int lastSignal = 0  // 1 for buy, -1 for sell, 0 for none
var int lastSignalBar = 0

// Buy Signal Logic
buySignal = false
sellSignal = false

// Check for bullish setups
[foundBullOB, bullOBTop, bullOBBottom] = detectBullishOrderBlock()
[foundBullFVG, bullFVGTop, bullFVGBottom] = detectBullishFVG()

// Check for bearish setups
[foundBearOB, bearOBTop, bearOBBottom] = detectBearishOrderBlock()
[foundBearFVG, bearFVGTop, bearFVGBottom] = detectBearishFVG()

// Generate buy signal only if:
// 1. Bullish setup detected
// 2. No sell signal at the same location
// 3. Market structure supports it
// 4. Trade limits allow it
if (foundBullOB or foundBullFVG) and lastStructure >= 0 and not (foundBearOB or foundBearFVG)
    if (lastSignal != 1 or bar_index - lastSignalBar > 5) and canTakeTrade()
        buySignal := true
        lastSignal := 1
        lastSignalBar := bar_index

// Generate sell signal only if:
// 1. Bearish setup detected
// 2. No buy signal at the same location
// 3. Market structure supports it
// 4. Trade limits allow it
if (foundBearOB or foundBearFVG) and lastStructure <= 0 and not (foundBullOB or foundBullFVG)
    if (lastSignal != -1 or bar_index - lastSignalBar > 5) and canTakeTrade()
        sellSignal := true
        lastSignal := -1
        lastSignalBar := bar_index

// ============================================================================
// ADD ZONES TO TRACKING ARRAYS (Non-overlapping)
// ============================================================================

// Clean old zones periodically
if bar_index % 10 == 0
    cleanOldZones(activeOrderBlocks)
    cleanOldZones(activeFVGs)

// Add Order Blocks
if foundBullOB and showOrderBlocks
    addZoneIfNoOverlap(activeOrderBlocks, bullOBTop, bullOBBottom, true)

if foundBearOB and showOrderBlocks
    addZoneIfNoOverlap(activeOrderBlocks, bearOBTop, bearOBBottom, false)

// Add Fair Value Gaps
if foundBullFVG and showFVG
    addZoneIfNoOverlap(activeFVGs, bullFVGTop, bullFVGBottom, true)

if foundBearFVG and showFVG
    addZoneIfNoOverlap(activeFVGs, bearFVGTop, bearFVGBottom, false)

// ============================================================================
// STRATEGY EXECUTION - Entry and Exit Rules
// ============================================================================

// Entry conditions with trade limiting
if buySignal and strategy.position_size == 0
    // Calculate stop loss and take profit levels
    stopLossLevel = close * (1 - stopLossPercent / 100)
    takeProfitLevel = close * (1 + takeProfitPercent / 100)
    
    // Enter long position
    strategy.entry("Long", strategy.long)
    strategy.exit("Exit Long", "Long", stop=stopLossLevel, limit=takeProfitLevel)
    
    // Update trade tracking
    lastTradeBar := bar_index
    dailyTradeCount += 1

if sellSignal and strategy.position_size == 0
    // Calculate stop loss and take profit levels
    stopLossLevel = close * (1 + stopLossPercent / 100)
    takeProfitLevel = close * (1 - takeProfitPercent / 100)
    
    // Enter short position
    strategy.entry("Short", strategy.short)
    strategy.exit("Exit Short", "Short", stop=stopLossLevel, limit=takeProfitLevel)
    
    // Update trade tracking
    lastTradeBar := bar_index
    dailyTradeCount += 1

// ============================================================================
// VISUALIZATION
// ============================================================================

// Draw Order Blocks
if showOrderBlocks and array.size(activeOrderBlocks) > 0
    for i = 0 to array.size(activeOrderBlocks) - 1
        zone = array.get(activeOrderBlocks, i)
        if bar_index <= zone.endBar
            box.new(
                 zone.startBar, zone.top, bar_index, zone.bottom,
                 border_color = zone.isBullish ? color.green : color.red,
                 bgcolor = zone.isBullish ? bullishColor : bearishColor,
                 border_width = 1
             )

// Draw Fair Value Gaps
if showFVG and array.size(activeFVGs) > 0
    for i = 0 to array.size(activeFVGs) - 1
        zone = array.get(activeFVGs, i)
        if bar_index <= zone.endBar
            box.new(
                 zone.startBar, zone.top, bar_index, zone.bottom,
                 border_color = zone.isBullish ? color.new(color.green, 50) : color.new(color.red, 50),
                 bgcolor = zone.isBullish ? color.new(color.green, 90) : color.new(color.red, 90),
                 border_width = 1,
                 border_style = line.style_dashed
             )

// Plot Buy/Sell Signals
plotshape(
     buySignal, 
     title="Buy Signal", 
     location=location.belowbar, 
     color=color.green, 
     style=shape.labelup, 
     text="BUY",
     textcolor=color.white,
     size=size.small
 )

plotshape(
     sellSignal, 
     title="Sell Signal", 
     location=location.abovebar, 
     color=color.red, 
     style=shape.labeldown, 
     text="SELL",
     textcolor=color.white,
     size=size.small
 )

// ============================================================================
// PERFORMANCE METRICS DISPLAY
// ============================================================================

// Display daily trade count and trade status on chart
var table perfTable = table.new(position.top_right, 2, 4, 
                                border_width=1, 
                                border_color=color.gray,
                                frame_width=1,
                                frame_color=color.gray)

if barstate.islast
    // Headers
    table.cell(perfTable, 0, 0, "Metric", bgcolor=color.gray, text_color=color.white)
    table.cell(perfTable, 1, 0, "Value", bgcolor=color.gray, text_color=color.white)
    
    // Daily trade count
    table.cell(perfTable, 0, 1, "Trades Today", bgcolor=color.new(color.blue, 80))
    table.cell(perfTable, 1, 1, str.tostring(dailyTradeCount), 
               bgcolor=dailyTradeCount >= maxTradesPerDay ? color.new(color.red, 80) : color.new(color.green, 80))
    
    // Bars since last trade
    barsSince = bar_index - lastTradeBar
    table.cell(perfTable, 0, 2, "Bars Since Trade", bgcolor=color.new(color.blue, 80))
    table.cell(perfTable, 1, 2, str.tostring(barsSince), bgcolor=color.new(color.blue, 80))
    
    // Can take trade status
    table.cell(perfTable, 0, 3, "Can Trade", bgcolor=color.new(color.blue, 80))
    table.cell(perfTable, 1, 3, canTakeTrade() ? "YES" : "NO",
               bgcolor=canTakeTrade() ? color.new(color.green, 80) : color.new(color.red, 80))
