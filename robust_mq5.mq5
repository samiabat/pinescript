//+------------------------------------------------------------------+
//|                                            LiquiditySweepEA.mq5 |
//|          V18: Banker/Runner + EAT/NY Time Conversion             |
//+------------------------------------------------------------------+
#property copyright "Generated by AI"
#property version   "3.00"

#include <Trade\Trade.mqh>

// --- INPUTS ---
input group "Strategy Settings"
input int      TrendLookback = 20;     // Trend Lookback Length
input double   BE_Trigger    = 1.5;    // Move to Breakeven at (Risk Multiple)
input double   TP1_Ratio     = 2.0;    // Banker Target (Reward Ratio)
input double   TP2_Ratio     = 4.0;    // Runner Target (Reward Ratio)
input double   RiskPercent   = 1.0;    // Total Risk per trade - Both positions combined (% of Equity)

input group "Time Zone Settings (EAT to NY)"
input bool     UseTimeFilter     = true;
input string   NY_Start_Time     = "09:30"; // New York Start Time
input string   NY_End_Time       = "16:00"; // New York End Time
input bool     Is_NY_Summer_Time = true;    // True = Summer (EDT), False = Winter (EST)
// NOTE: EAT is UTC+3. NY is UTC-4 (Summer) or UTC-5 (Winter).
// Offset: Summer = 7 Hours. Winter = 8 Hours.

input group "Stop Loss Settings"
input double   ATR_Multi     = 2.5;     // ATR Multiplier for SL (V17 Default)

// --- GLOBALS ---
int       handleATR;
CTrade    trade;
datetime  lastBarTime = 0;

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
  {
   // Initialize ATR Indicator (14 period)
   handleATR = iATR(_Symbol, _Period, 14);
   if(handleATR == INVALID_HANDLE)
     {
      Print("CRITICAL ERROR: Failed to create ATR handle");
      return(INIT_FAILED);
     }
   
   // Set magic number to identify these trades
   trade.SetExpertMagicNumber(123456);
   
   return(INIT_SUCCEEDED);
  }

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
  {
   // 1. Manage Open Positions (Trailing Break Even)
   ManageBreakeven();

   // 2. Check for New Bar (We only trade on the close of a candle)
   if(!IsNewBar()) return;

   // 3. EAT to NY Time Filter
   if(UseTimeFilter)
     {
      if(!IsNewYorkSession()) return;
     }

   // 4. Data Gathering
   // We need at least TrendLookback + 5 bars of history
   int requiredBars = TrendLookback + 5;
   
   double close[], open[], high[], low[];
   ArraySetAsSeries(close, true);
   ArraySetAsSeries(open, true);
   ArraySetAsSeries(high, true);
   ArraySetAsSeries(low, true);
   
   if(CopyClose(_Symbol, _Period, 0, requiredBars, close) < requiredBars ||
      CopyOpen(_Symbol, _Period, 0, 5, open) < 5 ||
      CopyHigh(_Symbol, _Period, 0, 5, high) < 5 ||
      CopyLow(_Symbol, _Period, 0, 5, low) < 5) return;

   // Get ATR Value for Index 1 (Last closed bar)
   double atrBuf[];
   ArraySetAsSeries(atrBuf, true);
   if(CopyBuffer(handleATR, 0, 1, 1, atrBuf) < 1) return;
   double currentATR = atrBuf[0];

   // --- LOGIC MAPPING ---
   // Index [1] is the Trigger Candle (Just Closed)
   
   // Context: Current Close vs Close 'Lookback' bars ago relative to Trigger
   bool isUptrend   = close[1] > close[1 + TrendLookback];
   bool isDowntrend = close[1] < close[1 + TrendLookback];
   
   // --- PATTERN RECOGNITION (V13 Logic) ---
   
   // Bearish (Sell) Setup
   // Green[2] -> Red[1] -> Red[0] (Trigger) -> Mapped to MQL5: Green[3]->Red[2]->Red[1]
   bool bear_1 = isUptrend && IsGreen(open, close, 3) && IsRed(open, close, 2) && IsRed(open, close, 1) &&
                 (high[1] > high[2]) && (close[1] < low[2]);

   // Bear 2: Green[4] -> Red[3] -> Red[2] -> Red[1]
   bool bear_2 = isUptrend && IsGreen(open, close, 4) && IsRed(open, close, 3) && IsRed(open, close, 2) && IsRed(open, close, 1) &&
                 (high[1] > MathMax(high[2], high[3])) && (close[1] < MathMin(low[2], low[3]));

   // Bullish (Buy) Setup
   // Red[3] -> Green[2] -> Green[1]
   bool bull_1 = isDowntrend && IsRed(open, close, 3) && IsGreen(open, close, 2) && IsGreen(open, close, 1) &&
                 (low[1] < low[2]) && (close[1] > high[2]);
                 
   // Bull 2: Red[4] -> Green[3] -> Green[2] -> Green[1]
   bool bull_2 = isDowntrend && IsRed(open, close, 4) && IsGreen(open, close, 3) && IsGreen(open, close, 2) && IsGreen(open, close, 1) &&
                 (low[1] < MathMin(low[2], low[3])) && (close[1] > MathMax(high[2], high[3]));

   bool validSell = bear_1 || bear_2;
   bool validBuy  = bull_1 || bull_2;
   
   // --- EXECUTION ---
   if(validBuy)
     {
      Print("Bullish Pattern Found on ", _Symbol);
      
      double padding = currentATR * ATR_Multi;
      double slPrice = NormalizeDouble(low[1] - padding, _Digits);
      
      if(!CheckStopLevel(POSITION_TYPE_BUY, slPrice)) return;

      double risk    = close[1] - slPrice;
      double tp1Price = NormalizeDouble(close[1] + (risk * TP1_Ratio), _Digits);
      double tp2Price = NormalizeDouble(close[1] + (risk * TP2_Ratio), _Digits);

      double halfLots = GetSplitLotSize(MathAbs(close[1] - slPrice));
      
      if(!trade.Buy(halfLots, _Symbol, 0, slPrice, tp1Price, "Banker")) 
         Print("Buy Error (Banker): ", GetLastError());
         
      if(!trade.Buy(halfLots, _Symbol, 0, slPrice, tp2Price, "Runner"))
         Print("Buy Error (Runner): ", GetLastError());
     }
     
   if(validSell)
     {
      Print("Bearish Pattern Found on ", _Symbol);
      
      double padding = currentATR * ATR_Multi;
      double slPrice = NormalizeDouble(high[1] + padding, _Digits);
      
      if(!CheckStopLevel(POSITION_TYPE_SELL, slPrice)) return;

      double risk    = slPrice - close[1];
      double tp1Price = NormalizeDouble(close[1] - (risk * TP1_Ratio), _Digits);
      double tp2Price = NormalizeDouble(close[1] - (risk * TP2_Ratio), _Digits);
      
      double halfLots = GetSplitLotSize(MathAbs(slPrice - close[1]));
      
      if(!trade.Sell(halfLots, _Symbol, 0, slPrice, tp1Price, "Banker"))
         Print("Sell Error (Banker): ", GetLastError());
         
      if(!trade.Sell(halfLots, _Symbol, 0, slPrice, tp2Price, "Runner"))
         Print("Sell Error (Runner): ", GetLastError());
     }
  }

//+------------------------------------------------------------------+
//| Helper: Time Zone Calculator                                     |
//+------------------------------------------------------------------+
bool IsNewYorkSession()
  {
   // 1. Get Current Server Time (Assumed EAT UTC+3)
   datetime serverTime = TimeCurrent();
   
   // 2. Calculate Offset based on Summer/Winter input
   // Summer (EDT): EAT is 7 hours ahead of NY.
   // Winter (EST): EAT is 8 hours ahead of NY.
   int offsetHours = Is_NY_Summer_Time ? 7 : 8;
   
   // 3. Create "Virtual" NY Time
   datetime nyTime = serverTime - (offsetHours * 3600);
   MqlDateTime nyDT;
   TimeToStruct(nyTime, nyDT);
   
   // 4. Parse Input Strings
   string s_arr[], e_arr[];
   StringSplit(NY_Start_Time, ':', s_arr);
   StringSplit(NY_End_Time, ':', e_arr);
   
   int startMin = (int)StringToInteger(s_arr[0]) * 60 + (int)StringToInteger(s_arr[1]);
   int endMin   = (int)StringToInteger(e_arr[0]) * 60 + (int)StringToInteger(e_arr[1]);
   int currMin  = nyDT.hour * 60 + nyDT.min;
   
   return (currMin >= startMin && currMin <= endMin);
  }

//+------------------------------------------------------------------+
//| Standard Helpers                                                 |
//+------------------------------------------------------------------+
bool IsNewBar()
  {
   datetime tm[];
   ArraySetAsSeries(tm,true);
   if(CopyTime(_Symbol, _Period, 0, 1, tm) < 0) return false;
   if(tm[0] != lastBarTime) { lastBarTime = tm[0]; return true; }
   return false;
  }

bool IsGreen(double& O[], double& C[], int idx) { return C[idx] > O[idx]; }
bool IsRed(double& O[], double& C[], int idx)   { return C[idx] < O[idx]; }

bool CheckStopLevel(ENUM_POSITION_TYPE type, double sl)
  {
   long stopLevel = SymbolInfoInteger(_Symbol, SYMBOL_TRADE_STOPS_LEVEL);
   double point   = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   double minDist = stopLevel * point;
   double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   
   if(type == POSITION_TYPE_BUY && MathAbs(ask - sl) < minDist) { Print("SL too close"); return false; }
   if(type == POSITION_TYPE_SELL && MathAbs(bid - sl) < minDist) { Print("SL too close"); return false; }
   return true;
  }

double GetSplitLotSize(double slDistance)
  {
   // Get symbol properties
   double tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
   double tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   double equity = AccountInfoDouble(ACCOUNT_EQUITY);
   double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   double maxLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
   double step = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   
   // Validate inputs
   if(slDistance <= 0 || tickValue <= 0 || tickSize <= 0)
     {
      Print("Invalid parameters for lot calculation. Using minimum lot.");
      return minLot;
     }
   
   // Calculate total risk money for BOTH positions combined
   double totalRiskMoney = equity * (RiskPercent / 100.0);
   
   // Calculate value of one point movement for one lot
   // This properly converts tick value to point value
   double pointValue = (tickValue / tickSize) * _Point;
   
   // Calculate stop loss in points
   double slPoints = slDistance / _Point;
   
   // Calculate TOTAL lot size needed to risk the specified percentage
   // Formula: Risk Money = Lot Size × Stop Loss in Points × Point Value
   // Therefore: Lot Size = Risk Money / (Stop Loss in Points × Point Value)
   double totalLotSize = totalRiskMoney / (slPoints * pointValue);
   
   // Since we open 2 positions (Banker and Runner), split the lot size
   // Each position will risk half of the total risk percentage
   double halfLots = totalLotSize / 2.0;
   
   // Normalize to step size (round down to nearest valid lot size)
   halfLots = MathFloor(halfLots / step) * step;
   
   // Apply minimum and maximum lot size constraints
   if(halfLots < minLot)
     {
      // For small accounts, ensure we can at least trade minimum lot
      Print("Calculated lot size ", halfLots, " is below minimum. Using ", minLot);
      halfLots = minLot;
     }
   
   if(halfLots > maxLot)
     {
      Print("Calculated lot size ", halfLots, " exceeds maximum. Using ", maxLot);
      halfLots = maxLot;
     }
   
   // Log the calculation for debugging
   // Note: This will log every time a position is calculated. 
   // For production use with high-frequency trading, consider adding a debug flag
   Print("Position Sizing: Equity=", equity, " Risk%=", RiskPercent, 
         " RiskMoney=", totalRiskMoney, " SL Points=", slPoints,
         " Point Value=", pointValue, " Half Lots=", halfLots);
   
   return halfLots;
  }

void ManageBreakeven()
  {
   for(int i = PositionsTotal() - 1; i >= 0; i--)
     {
      ulong ticket = PositionGetTicket(i);
      if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
      if(PositionGetInteger(POSITION_MAGIC) != 123456) continue;
      
      double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
      double currentSL = PositionGetDouble(POSITION_SL);
      double currentTP = PositionGetDouble(POSITION_TP);
      long   type      = PositionGetInteger(POSITION_TYPE);
      
      if(MathAbs(currentSL - openPrice) < _Point * 5) continue; // Already at BE
      
      double currentPrice = (type == POSITION_TYPE_BUY) ? SymbolInfoDouble(_Symbol, SYMBOL_BID) : SymbolInfoDouble(_Symbol, SYMBOL_ASK);
      
      if(type == POSITION_TYPE_BUY)
        {
         double riskPoints = openPrice - currentSL;
         if(riskPoints > 0 && currentPrice >= openPrice + (riskPoints * BE_Trigger))
           {
            trade.PositionModify(ticket, openPrice, currentTP);
            Print("Moved Buy to Breakeven");
           }
        }
      else if(type == POSITION_TYPE_SELL)
        {
         double riskPoints = currentSL - openPrice;
         if(riskPoints > 0 && currentPrice <= openPrice - (riskPoints * BE_Trigger))
           {
            trade.PositionModify(ticket, openPrice, currentTP);
            Print("Moved Sell to Breakeven");
           }
        }
     }
  }
